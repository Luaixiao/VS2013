#pragma once  
/**
*A*算法对象类
*/
#include <vector>  
#include <list>  

//常量
const int kCost1 = 10; //直移一格消耗  
const int kCost2 = 14; //斜移一格消耗  

struct Point
{
	int x, y; //点坐标，x代表横排，y代表竖列  
	int F, G, H; //F=G+H  
	Point *parent; //parent的坐标，这里没有用指针，从而简化代码  
	Point(int _x, int _y) :x(_x), y(_y), F(0), G(0), H(0), parent(0){}  //变量初始化  
};


class Astar
{
private:
	std::vector<std::vector<int> > maze; //存放二维数组
	std::list<Point *> openList;  //开启列表  
	std::list<Point *> closeList; //关闭列表  
public:
	//声明得到地图函数
	void InitAstar(std::vector<std::vector<int> > &_maze);
	//声明得到下一节点的函数
	std::list<Point *> GetPath(Point &startPoint, Point &endPoint, bool isIgnoreCorner);

private:
	//查找路径的函数
	Point *findPath(Point &startPoint, Point &endPoint, bool isIgnoreCorner);
	//声明得到当前节点周围节点的常成员函数
	std::vector<Point *> getSurroundPoints(const Point *point, bool isIgnoreCorner) const;
	//判断某点是否可以用于下一步判断的常函数
	bool isCanreach(const Point *point, const Point *target, bool isIgnoreCorner) const;
	//判断开启/关闭列表中是否包含某点的常函数  
	Point *isInList(const std::list<Point *> &list, const Point *point) const; 
	//从开启列表中返回F值最小的节点  
	Point *getLeastFpoint(); 
	//计算F、G、H值  
	int calcG(Point *temp_start, Point *point);
	int calcH(Point *point, Point *end);
	int calcF(Point *point);
};
